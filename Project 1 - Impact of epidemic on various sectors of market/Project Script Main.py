# -*- coding: utf-8 -*-
"""Investment strategy with sharpe.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZWQ79w7UC2P8ztiA3yhff90CSdoTz4OY
"""

import pandas as pd
import pandas_datareader.data as pdr

#Loading in the primary lists

it_tickers = list("TCS	INFY	HCLTECH	WIPRO	TECHM	LTI	HONAUT	BEL	OFSS	MPHASIS	MINDTREE	HEXAWARE	NIITTECH	TATAELXSI	PERSISTENT	INFIBEAM	REDINGTON	VAKRANGEE	FSL	ZENSARTECH	CYIENT	BSOFT	SONATSOFTW	ECLERX	KPITTECH	INTELLECT	ACCELYA	HGS	RSYSTEMS	TANLA	NEWGEN	ASTRAMICRO	MAJESCO	MASTEK	AGCNET	NUCLEUS	CIGNITITEC	QUICKHEAL	SASKEN	GENUSPOWER".split())
finance_tickers = list("HDFCBANK	HDFC	KOTAKBANK	ICICIBANK	BAJFINANCE	SBIN	AXISBANK	HDFCLIFE	BAJAJFINSV	SBILIFE	SBICARD	BANDHANBNK	ICICIPRULI	ICICIGI	HDFCAMC	IDBI	MUTHOOTFIN	INDUSINDBK	PNB	PEL	YESBANK	BAJAJHLDNG	BANKBARODA	PFC	RECLTD	AUBANK	NIACL	NAM-INDIA	IOB	CHOLAFIN	ISEC	BANKINDIA	IDFCFIRSTB	CANBK	MFSL	ABCAPITAL	LICHSGFIN	L&TFH".split())
real_estate_tickers = list("DLF	GODREJPROP	PHOENIXLTD	PRESTIGE	IBREALEST	NESCO	BRIGADE	SUNTECK	SOBHA	OMAXE	MAHLIFE	ANANTRAJ	ASHIANA	TEXINFRA	IBULISL	KARDA	BINDALAGRO	ARVSMART	PROZONINTU	MARATHON	VIPULLTD	NILAINFRA	DBREALTY	HDIL	PARSVNATH	GEECEE	GANESHHOUC	PODDARHOUS	FMNL	PENINLAND	EMAMIREAL	TCIDEVELOP".split())
consumer_discretionary_tickers = list("MARUTI	DMART	TITAN	BAJAJ-AUTO	M&M	HEROMOTOCO	BOSCHLTD	TATAMOTORS	MOTHERSUMI	WHIRLPOOL	MRF	BALKRISIND	SRF	TRENT	PAGEIND	JUBLFOOD	VOLTAS	TVSMOTOR	BATAINDIA	RELAXO	CROMPTON	RAJESHEXPO	WABCOINDIA	ENDURANCE	SCHAEFFLER	ABFRL	INDHOTEL	TIINDIA	SUNDRMFAST	MINDAIND	TTKPRESTIG	DIXON	SFL	APOLLOTYRE	SYMPHONY	JCHAC	FRETAIL	AMBER".split())
consumer_staples_tickers = list("HINDUNILVR	ITC	NESTLEIND	BRITANNIA	DABUR	GODREJCP	MCDOWELL-N	MARICO	TATACONSUM	COLPAL	PGHH	RUCHI	UBL	VBL	GILLETTE	HATSUN	EMAMILTD	GODREJAGRO	BBTC	ZYDUSWELL	AVANTIFEED	KRBL	RADICO	VSTIND	GODFRYPHLP	EIDPARRY	JYOTHYLAB	KSCL	CCL	TASTYBITE	BALRAMCHIN	FCONSUMER	BAJAJCON	RENUKA	GAEL	TATACOFFEE	VENKEYS	DAAWAT	TRIVENI	DIAMONDYD".split())
communication_services_tickers = list("BHARTIARTL	INFRATEL	NAUKRI	IDEA	IRCTC	ZEEL	SUNTV	ITI	INDIAMART	TV18BRDCST	PVR	HATHWAY	STRTECH	AFFLE	 NETWORK18	DEN	JUSTDIAL	INOXLEISUR	HFCL	NAVNETEDUL	DBCORP	DISHTV	TVTODAY	JAGRAN	MATRIMONY	VINDHYATEL	NXTDIGITAL	BALAJITELE	GTPL	SAREGAMA	TTML	MTNL	ENIL	RADIOCITY	JUMPNET	MPSLTD".split())
health_care_tickers = list("SUNPHARMA	DRREDDY	DIVISLAB	CIPLA	BIOCON	AUROPHARMA	TORNTPHARM	LUPIN	CADILAHC	ABBOTINDIA	ALKEM	GLAXO	IPCALAB	APOLLOHOSP	PFIZER	APLLTD	SANOFI	SYNGENE	LALPATHLAB	AJANTPHARM	NATCOPHARM	GLENMARK	JUBILANT	FORTIS	ASTRAZEN	METROPOLIS	PGHL	SUVENPHAR	LAURUSLABS	ASTERDM	ERIS	NH	GRANULES	JBCHEPHARM	SPARC	SHILPAMED	FDC	STAR	AARTIDRUGS	POLYMED".split())
industrials_tickers = list("LT	ADANIPORTS	EICHERMOT	SIEMENS	INDIGO	HAVELLS	HAL	CONCOR	3MINDIA	ABB	ADANIENT	AIAENG	ASHOKLEY	LTTS	BHEL	ESCORTS	ASTRAL	EXIDEIND	POLYCAB	GMRINFRA	AMARAJABAT	CUMMINSIND	THERMAX	SKFINDIA	BDL	TIMKEN	VGUARD	KEC	RITES	KAJARIACER	GMMPFAUDLR	FINPIPE	GRINDWELL	SIS	QUESS	WESTLIFE	CARBORUNIV	RATNAMANI	BLUEDART	NBCC".split())
materials_tickers = list("ASIANPAINT	ULTRACEMCO	COALINDIA	SHREECEM	HINDZINC	PIDILITIND	BERGEPAINT	JSWSTEEL	VEDL	GRASIM	AMBUJACEM	TATASTEEL	HINDALCO	UPL	BAYERCROP	NMDC	ACC	PIIND	KANSAINER	COROMANDEL	JINDALSTEL	BHARATFORG	AARTIIND	RAMCOCEM	SAIL	SUPREMEIND	ATUL	SUMICHEM	DALBHARAT	GODREJIND	CASTROLIND	JKCEMENT	VINATIORGA	SOLARINDS	NAVINFLUOR	AKZOINDIA	TATACHEM	DEEPAKNTR	NATIONALUM	CHAMBLFERT".split())
list_of_tickers = [it_tickers, finance_tickers, real_estate_tickers, consumer_discretionary_tickers, consumer_staples_tickers, communication_services_tickers, health_care_tickers, industrials_tickers, materials_tickers]
list_of_sectors = ['IT','Finance','Real Estate','Cons. Discretionary','Cons. Staples','Comms Services','Health Care','Industrials','Materials']

#appending .NS to each name to use with yahoo

for industry in list_of_tickers:
    i=0
    for _ in industry:
        industry[i] = industry[i]+".NS"
        i+=1

# fetching data

start_date = pd.to_datetime("2019-12-31")
end_date = pd.to_datetime("2020-12-31")


universe = {}
i=0
for ind in list_of_tickers:
    attempts = 0
    drop = []
    universe[list_of_sectors[i]] = {}
    while len(ind) != 0 and attempts < 5 :
        ind = [j for j in ind if j not in drop]
        for tick in ind:
            try:
                print("Fetching :", tick)
                universe[list_of_sectors[i]][tick] = pdr.get_data_yahoo(tick, start_date, end_date)
                drop.append(tick)
            except:
                print("Unable to fetch {}. Retrying ....".format(tick))
                continue
        attempts+=1
    ind = drop
    i+=1

# fetching NIFTY50

nifty50 = pdr.get_data_yahoo('^NSEI', start_date, end_date)

# universe is a dictionary in which keys are sector names corresponding to list of sectors, which point toward another dictionary. This dictionary has keys corresponding
# to stock symbols which point toward a pandas dataframe which contains stock info forthe given date range. Checked. ALL OK

##########################################################################   Everything above works  #################################################################################

import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import math
import operator
import collections
import random
from scipy.optimize import minimize

# Finding the top and bottom 5 returns in each sector using Close prices of the day, for buy and hold strategy

max_hold_returns = {}
min_hold_returns = {}

for ind in universe:
  i=0
  max_rets = {}
  min_rets = {}
  for stock in universe[ind]:
    if i<5 :
      max_rets[stock] = universe[ind][stock]['Close'][-1]/universe[ind][stock]['Close'][0]
      min_rets[stock] = max_rets[stock]
      i+=1
    else :
      sorted_max = sorted(max_rets.items(), key=operator.itemgetter(1), reverse=True)
      sorted_min = sorted(min_rets.items(), key=operator.itemgetter(1), reverse=False)
      max_rets = collections.OrderedDict(sorted_max)
      min_rets = collections.OrderedDict(sorted_min)
      if (universe[ind][stock]['Close'][-1]/universe[ind][stock]['Close'][0]) > max_rets[list(max_rets.keys())[-1]] :
        to_delete = list(max_rets.keys())[-1]
        max_rets[stock] = (universe[ind][stock]['Close'][-1]/universe[ind][stock]['Close'][0])
        del max_rets[to_delete]
      if (universe[ind][stock]['Close'][-1]/universe[ind][stock]['Close'][0]) < min_rets[list(min_rets.keys())[0]] :
        to_delete = list(min_rets.keys())[0]
        min_rets[stock] = (universe[ind][stock]['Close'][-1]/universe[ind][stock]['Close'][0])
        del min_rets[to_delete]
  max_hold_returns[ind] = max_rets
  min_hold_returns[ind] = min_rets
'''
for x in max_hold_returns :
  print("Best Buy and Hold Returns in",x)
  print(max_hold_returns[x])
  print("Worst Buy and Hold Returns in",x)
  print(min_hold_returns[x])
  print("_______________________________________________________________________________________________________________________________________________________________________________________________________________________________")
'''

# Finding the 5 most and least relatively volatile stocks in each sector using Close prices of the day (Standard Deviation)

max_volatility = {}
min_volatility = {}

for ind in universe :
  i=0
  max_vol = {}
  min_vol = {}
  for stock in universe[ind] :
    if i<5 :
      max_vol[stock] = universe[ind][stock]['Close'].std()/universe[ind][stock]['Close'][-1]
      min_vol[stock] = max_vol[stock]
      i+=1
    else :
      sorted_max = sorted(max_vol.items(), key=operator.itemgetter(1), reverse=True)
      sorted_min = sorted(min_vol.items(), key=operator.itemgetter(1), reverse=False)
      max_vol = collections.OrderedDict(sorted_max)
      min_vol = collections.OrderedDict(sorted_min)
      if universe[ind][stock]['Close'].std() > max_vol[list(max_vol.keys())[-1]] :
        to_delete = list(max_vol.keys())[-1]
        max_vol[stock] = universe[ind][stock]['Close'].std()/universe[ind][stock]['Close'][-1]
        del max_vol[to_delete]
      if universe[ind][stock]['Close'].std() < min_vol[list(min_vol.keys())[0]] :
        to_delete = list(min_vol.keys())[0]
        min_vol[stock] = universe[ind][stock]['Close'].std()/universe[ind][stock]['Close'][-1]
        del min_vol[to_delete]
  max_volatility[ind] = max_vol
  min_volatility[ind] = min_vol
'''
for x in max_volatility :
  print("Most Volatile in",x)
  print(max_volatility[x])
  print("Least Volatile in",x)
  print(min_volatility[x])
  print("__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________")
'''

# Finding the stock from each sector that had the maximum drawdown during the period

drawdowns = {}

for ind in universe :
  dd = 0
  for stock in universe[ind] :
    maxpr = universe[ind][stock]['Close'].max()
    minpr = universe[ind][stock]['Close'].min()
    if dd < (maxpr-minpr) :
      dd = maxpr-minpr
      st = stock
  drawdowns[ind] = {st:dd}

#print("Stocks that had the maximum Drawdowns in each sector:")
#print(drawdowns)

# finding the sharpe ratio of each individual stock in each sector, pct change of daily rets used

sharpe_ratios = {}
risk_free = 0.0

for ind in universe:
  td = {}
  for stock in universe[ind] :
    temp = universe[ind][stock]
    temp['Daily Returns'] = temp['Close'].pct_change(1)
    mean = temp['Daily Returns'].mean()
    std = temp['Daily Returns'].std()
    sharpe = (mean-risk_free)/std
    td[stock] = (252**0.5)*sharpe

  sharpe_ratios[ind] = td

#print(sharpe_ratios)

# Using Monte Carlo Simulation, building portfolio with 5 stocks from every sector

'''
total_companies = len(list(universe['Health Care'].keys()))
selection = random.sample(range(0,total_companies),5)
curr_stocks_list = [list(universe['Health Care'].keys())[j] for j in selection]
curr_stocks_df = pd.concat([universe['Health Care'][j]['Close'] for j in curr_stocks_list], axis=1)
curr_stocks_df.columns = curr_stocks_list

num_ports = 5000
all_weights = np.zeros((num_ports, len(curr_stocks_df.columns)))
ret_arr = np.zeros(num_ports)
vol_arr = np.zeros(num_ports)
sharpe_arr = np.zeros(num_ports)

for index in range(num_ports) :
  log_ret = np.log(curr_stocks_df/curr_stocks_df.shift(1)) #detrending the returns
  weights = np.array(np.random.random(5))
  weights = weights/np.sum(weights) #Rebalancing
  all_weights[index,:] = weights
  ret_arr[index] = np.sum((log_ret.mean() * weights) * 252 )
  vol_arr[index] = np.sqrt(np.dot(weights.T,np.dot(log_ret.cov()*252, weights)))
  sharpe_arr[index] = (ret_arr[index]) / vol_arr[index]

plt.figure(figsize=(12,8))
plt.scatter(vol_arr,ret_arr,c = sharpe_arr, cmap='plasma')
plt.colorbar(label='Sharpe Ratio')
plt.xlabel('Volatility')
plt.ylabel('Expected Returns')

plt.scatter(vol_arr[sharpe_arr.argmax()], ret_arr[sharpe_arr.argmax()], c='r', s=50, edgecolor='black')
'''

# MC Ends

# markovitz optimozation

# we need a log return df as functions will use it directly. Also, function needs to be defined after log_rets

# Selecting 5 Most suited stocks from each sector and calculating their weights

portfolio = pd.DataFrame()
stock_weights = {}

for ind in universe:
  
  best_stocks_in_sector = []
  best_weights_in_sector = []
  best_sr = -10000.0
  t = list()
  for _ in range(0,20):
    indices = random.sample(range(0, len(list(universe[ind].items()))), 5)
    stocks_list = [list(universe[ind].keys())[j] for j in indices]
    stocks_df = pd.concat([universe[ind][j]['Close'] for j in stocks_list], axis=1)
    stocks_df.columns = stocks_list
    log_ret = np.log(stocks_df/stocks_df.shift(1))
    
    def get_ret_vol_sr(weights):
      weights = np.array(weights)
      ret = np.sum(log_ret.mean() * weights) * 252
      vol = np.sqrt(np.dot(weights.T, np.dot(log_ret.cov() * 252, weights)))
      sr = ret/vol
      return np.array([ret,vol,sr])

    def neg_sharpe(weights):
      return  get_ret_vol_sr(weights)[2] * -1

    def check_sum(weights):
      return np.sum(weights) - 1

    cons = ({'type':'eq','fun': check_sum})
    bounds = ((0, 1), (0, 1), (0, 1), (0, 1), (0, 1))
    init_guess = [0.2,0.2,0.2,0.2,0.2]
    opt_results = minimize(neg_sharpe,init_guess,method='SLSQP',bounds=bounds,constraints=cons)
    
    if (get_ret_vol_sr(opt_results.x)[-1]) > best_sr :
      best_sr = get_ret_vol_sr(opt_results.x)[-1]
      best_stocks_in_sector = stocks_list
      best_weights_in_sector = opt_results.x

  sector_stocks_df = pd.concat([universe[ind][j]['Close'] for j in best_stocks_in_sector], axis=1)
  sector_stocks_df.columns = best_stocks_in_sector
  sector_norm_ret = sector_stocks_df/sector_stocks_df.shift(1)

  for a,b in zip(best_stocks_in_sector, best_weights_in_sector) :
    t.append((a,b))
  stock_weights[ind] = t

  sector_norm_ret[ind+' Returns'] = sector_norm_ret.apply(lambda _: 0, axis=1)
  for x, y in zip(sector_norm_ret.columns, best_weights_in_sector) :
    sector_norm_ret[ind+' Returns'] = sector_norm_ret[ind+' Returns']+sector_norm_ret[x]*y

  portfolio[ind + ' Returns'] = sector_norm_ret[ind+' Returns']

#print(portfolio)
#print(stock_weights)

# Calculating weights for each Sector

sector_weights = list()

def get_ret_vol_sr(weights):
  weights = np.array(weights)
  ret = np.sum(portfolio.mean() * weights) * 252
  vol = np.sqrt(np.dot(weights.T, np.dot(portfolio.cov() * 252, weights)))
  sr = ret/vol
  return np.array([ret,vol,sr])

def neg_sharpe(weights):
  return  get_ret_vol_sr(weights)[2] * -1

def check_sum(weights):
  return np.sum(weights) - 1

cons = ({'type':'eq','fun': check_sum})
bounds = ((0, 1), (0, 1), (0, 1), (0, 1), (0, 1), (0, 1), (0, 1), (0, 1), (0, 1))
init_guess = [0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.2]
opt_results = minimize(neg_sharpe,init_guess,method='SLSQP',bounds=bounds,constraints=cons)

pf_copy = portfolio.copy()

pf_copy['Total Returns'] = pf_copy.apply(lambda _: 0, axis=1)
for x, y, z in zip(pf_copy.columns,opt_results.x, list_of_sectors) :
  pf_copy['Total Returns'] = pf_copy['Total Returns']+pf_copy[x]*y
  sector_weights.append((z,y))


#print(pf_copy.tail())
#print(sector_weights)

#Final Results and Visualization

plt.figure(figsize=(20,6))
plt.plot(pf_copy['Total Returns'], label="Strategy Daily Returns", c='r')
plt.plot(nifty50['Close']/nifty50['Close'].shift(1),c='g',label="Nifty Daily Returns")
plt.title("Nifty50 Daily Returns vs Strategy Daily Returns")
plt.legend()
plt.show()

# Total Returns

overall_portfolio = pd.DataFrame()

for ind in universe :
  sector_portfolio = pd.DataFrame()
  for tupple in stock_weights[ind] :
    name, weight = tupple
    sector_portfolio[name] = universe[ind][name]['Close']
    sector_portfolio[name] = (sector_portfolio[name]*weight) / sector_portfolio[name][0]
  sector_portfolio[ind+' Total Return'] = sector_portfolio.sum(axis=1)
  overall_portfolio[ind] = sector_portfolio[ind+' Total Return']
  #print(sector_portfolio)


for tp in sector_weights :
  sec, wt = tp
  overall_portfolio[sec] = overall_portfolio[sec] * wt

overall_portfolio['Total Return'] = overall_portfolio.sum(axis=1)
init_money = int(input("Enter Initial Amount to be Invested: "))
overall_portfolio['Total Position'] = overall_portfolio['Total Return']*init_money
print(overall_portfolio)

#Compare Nifty Growth with Strategy Growth

nifty50['Total Return'] = nifty50['Close']/nifty50['Close'][0]

plt.figure(figsize=(20,6))
plt.plot(overall_portfolio['Total Return'], label="Strategy Growth", c='r')
plt.plot(nifty50['Total Return'],c='g',label="Nifty Growth")
plt.title("Money Growth Nifty50 vs Strategy")
plt.legend()
plt.show()

### Project Finished ###